/**
 * @author Ravi Gaddipati
 * @date June 24, 2016
 * rgaddip1@jhu.edu
 *
 * @brief
 * Defines a set of subgraphs from a given reference
 * and vcf file.
 *
 * @file
 */

#ifndef VARGAS_GDEF_H
#define VARGAS_GDEF_H

#include <string>
#include <map>
#include <fstream>
#include "graph.h"

#define GDEF_FILE_MARKER "@gdef"
#define GDEF_REF "ref"
#define GDEF_VCF "vcf"
#define GDEF_REGION "reg"
#define GDEF_NODELEN "nlen"
#define GDEF_NEGATE '~'
#define GDEF_SCOPE ':'
#define GDEF_ASSIGN '='
#define GDEF_DELIM ';'

namespace Vargas {

  /**
   * @brief
   * Create and manage a graph and specified subgraphs.
   * @details
   * Given a reference sequence and a variant call file, a GDEF file uniquely defines a set of
   * subgraphs deriving from the base graph. Subgraphs are generated by filtering the base graph
   * based on the number of samples in the graph. \n
   * Subgraphs are generated from parent graphs, with the top level base graph implied as 100%. ':' indicates
   * a child graph, '~' indicates the complement population. Multiple definitions are delimited with ';',
   * and all labels must be defined before being referenced. For example:
   * @code{.unparsed}
   * "a=10" # Choose 10 samples from the base graph
   * "b=5%" # Choose 5% of the samples in the base graph
   * "a:c=5" # Choose 5 of the 10 samples in 'a'
   * "~a:d=5" # Choose 5 samples from the complement population of 'a'
   * "a:~e=5" # Invalid, complement graphs are implicit and cannot be directly defined.
   * @endcode
   * \n
   * GDEF file format:
   * @code{.unparsed}
   * \@gdef
   * ref=REFERENCE,var=VCF,reg=REGION,nlen=NODE_LEN
   * label=POP_FILTER
   * ...
   * @endcode
   * \n
   * Usage:
   * @code{.cpp}
   * #include <gdef.h>
   *
   * int main() {
   *    Vargas::GraphManager gm();
   *    gm.write("ref.fasta", "variants.vcf", "x:0-100", "a=50;a:b=10;~a:c=10%", 1000, "out.gdf");
   *
   *    gm.load("out.gdf");
   *    gm.base(); // shared_ptr to whole graph
   *    gm.subgraph("a"); // 'a' subgraph
   *    gm.subgraph("~a"); // complement of 'a' subgraph
   *    gm.subgraph("c"); // Invalid
   *    gm.subgraph("~a:c") // valid
   *
   * }
   * @endcode
   *
   */
  class GraphManager {
    public:

      GraphManager() {}

      /**
       * @brief
       * Open a GDEF file.
       * @param gdef_file file name
       * @throws std::invalid_argument Failed to open the input file.
       */
      GraphManager(std::string gdef_file) {
          if (!open(gdef_file)) throw std::invalid_argument("Invalid GDEF file \"" + gdef_file + "\"");
      }

      ~GraphManager() { close(); }

      /**
       * @brief
       * Remove any graphs.
       */
      void close() {
          _base_graph.reset();
          _subgraph_filters.clear();
          _subgraphs.clear();
      }

      /**
       * @brief
       * Open a GDEF file.
       * @param file_name
       * @return true on success
       */
      bool open(std::string file_name = "") {
          if (file_name.length() == 0) open(std::cin);
          std::ifstream in(file_name);
          if (!in.good()) return false;
          return open(in);
      }

      /**
       * @brief
       * Read a GDEF file from an input stream
       * @param in input stream
       * @return true on success
       * @throws std::invalid_argument Invalid token or a duplicate definition
       * @throws std::range_error Filter length does not match the number of samples in the VCF file
       */
      bool open(std::istream &in) {
          std::string line;

          // Check file type, get next line
          if (!std::getline(in, line) || line != GDEF_FILE_MARKER || !std::getline(in, line)) return false;

          // Pull meta info
          std::string ref, vcf, region;
          int node_len;
          {
              std::vector<std::string> meta_split = split(line, GDEF_DELIM);
              std::vector<std::string> tv_pair;
              for (const std::string &tv : meta_split) {
                  split(tv, GDEF_ASSIGN, tv_pair);
                  if (tv_pair.size() != 2) throw std::invalid_argument("Invalid token: \"" + tv + "\"");
                  const std::string &tag = tv_pair[0];
                  const std::string &val = tv_pair[1];
                  if (tag == GDEF_REF) ref = val;
                  else if (tag == GDEF_VCF) vcf = val;
                  else if (tag == GDEF_REGION) region = val;
                  else if (tag == GDEF_NODELEN) node_len = std::stoi(val);
              }
          }

          // Build base graph
          unsigned nsamps;
          {
              GraphBuilder gb(ref, vcf);
              gb.region(region);
              gb.node_len(node_len);
              _base_graph = std::make_shared<Graph>(gb.build());
              VCF vcf_stream(vcf);
              nsamps = vcf_stream.num_samples() * 2;
          }

          // subgraphs
          {
              std::vector<std::string> p_pair;
              Graph::Population pop(nsamps);
              while (std::getline(in, line)) {
                  split(line, GDEF_ASSIGN, p_pair);

                  if (p_pair.size() != 2)
                      throw std::invalid_argument("Invalid token: \"" + line + "\"");
                  if (p_pair[1].length() != nsamps)
                      throw std::range_error("Population length does not match VCF file: \"" + p_pair[0] + "\"");

                  pop.reset();
                  for (size_t i = 0; i < p_pair[1].length(); ++i) {
                      if (p_pair[1][i] == '1') pop.set(i);
                  }
                  if (_subgraph_filters.count(p_pair[0]))
                      throw std::invalid_argument("Duplicate definition: \"" + p_pair[0] + "\"");

                  _subgraph_filters[p_pair[0]] = pop;
              }
          }

          return true;
      }

      /**
       * @brief
       * Create a subgraph if it does not exist. If it was previously constructed, get a shared_ptr.
       * @param label subgraph name
       * @return shared_ptr to graph
       * @throws std::invalid_argument Label does not exist
       */
      std::shared_ptr<const Graph> subgraph(std::string label) {
          label = "B:" + label;
          if (_subgraphs.count(label)) return _subgraphs.at(label);
          if (!_subgraph_filters.count(label)) throw std::invalid_argument("Label \"" + label + "\" does not exist.");
          #pragma omp critical
          {
              _subgraphs[label] = std::make_shared<Graph>(*_base_graph, _subgraph_filters.at(label));
          }
          return _subgraphs.at(label);
      }

      /**
       * @brief
       * Full graph
       * @return shared_ptr to base graph
       */
      std::shared_ptr<const Graph> base() const { return _base_graph; }

      /**
       * @brief
       * Get the population filter for a label
       * @param label subgraph label
       * @return Graph::Population to derive subgraph from base graph
       * @throws std::invalid_argument Label does not exist
       */
      Graph::Population filter(std::string label) const {
          label = "B:" + label;
          if (!_subgraph_filters.count(label)) throw std::invalid_argument("Label \"" + label + "\" does not exist.");
          return _subgraph_filters.at(label);
      }

      /**
       * @brief
       * Remove local reference to a graph. Removing after creation of the graph
       * will free memory once all users destroy their shared_ptr's.
       * @param label graph name
       */
      void destroy(std::string label) {
          #pragma omp critical
          {
              _subgraphs.erase("B:" + label);
          }
      }

      /**
       * @brief
       * Remove all local references to subgraphs. The base graph is preserved.
       */
      void clear() {
          _subgraphs.clear();
      }

      /**
       * @brief
       * Parse a defintion string a write a GDEF file.
       * @param ref_file Reference file name
       * @param vcf_file Variant file name
       * @param region Region in the format 'CHR:MIN-MAX'
       * @param defs subgraph definition string
       * @param node_len maximum graph node length.
       * @param out_file Output file name
       * @return true on success
       */
      bool write(std::string ref_file,
                 std::string vcf_file,
                 std::string region,
                 const std::string &defs,
                 int node_len,
                 std::string out_file = "") const {
          if (out_file.length() == 0) write(ref_file, vcf_file, region, defs, node_len, std::cout);
          std::ofstream out(out_file);
          if (!out.good()) return false;
          return write(ref_file, vcf_file, region, defs, node_len, out);
      }

      /**
       * @brief
       * Parse a defintion string a write a GDEF file.
       * @param ref_file Reference file name
       * @param vcf_file Variant file name
       * @param region Region in the format 'CHR:MIN-MAX'
       * @param defs subgraph definition string
       * @param node_len maximum graph node length.
       * @param out output stream
       * @param nsamps if unspecified the number of samples will be determined from the VCF file
       * @return true on success
       */
      bool write(std::string ref_file,
                 std::string vcf_file,
                 std::string region,
                 std::string defs_str,
                 int node_len,
                 std::ostream &out,
                 int nsamps = 0) const {

          out << GDEF_FILE_MARKER << std::endl
              << GDEF_REF << GDEF_ASSIGN << ref_file << GDEF_DELIM
              << GDEF_VCF << GDEF_ASSIGN << vcf_file << GDEF_DELIM
              << GDEF_REGION << GDEF_ASSIGN << region << GDEF_DELIM
              << GDEF_NODELEN << GDEF_ASSIGN << node_len << std::endl;


          // Replace new lines with the delim, remove any spaces
          std::replace(defs_str.begin(), defs_str.end(), '\n', GDEF_DELIM);
          defs_str.erase(std::remove_if(defs_str.begin(), defs_str.end(), isspace), defs_str.end());
          std::vector<std::string> defs = split(defs_str, GDEF_DELIM);

          // Get number of samples from VCF file
          if (nsamps == 0) {
              VCF vcf(vcf_file);
              if (!vcf.good()) throw std::invalid_argument("Invalid VCF file \"" + vcf_file + "\".");
              nsamps = vcf.num_samples() * 2;
          }

          std::unordered_map<std::string, Graph::Population> populations;

          {
              std::vector<std::string> pair;
              Graph::Population pop(nsamps);
              std::vector<int> avail_set;
              std::set<int> added;
              size_t count, r;
              std::string parent;
              size_t parent_end;

              // Base graph "B" uses the full filter
              {
                  Graph::Population base(nsamps);
                  base.set();
                  populations.insert(std::pair<std::string, Graph::Population>("B", base));
                  base.reset();
              }

              for (auto def : defs) {
                  split(def, GDEF_ASSIGN, pair);
                  if (pair.size() != 2) throw std::invalid_argument("Invalid assignment: \"" + def + "\".");
                  pop.reset();

                  if (pair[0].length() < 3 || pair[0].substr(0, 2) != "B:") pair[0] = "B:" + pair[0];
                  parent_end = pair[0].find_last_of(GDEF_SCOPE);
                  parent = pair[0].substr(0, parent_end);

                  if (populations.count(parent) == 0)
                      throw std::invalid_argument("Parent \"" + parent + "\" not yet defined.");

                  if (pair[0].at(parent_end + 1) == '~')
                      throw std::invalid_argument("Negative graphs cannot be defined explicitly: \"" + def + "\".");

                  if (pair[1].at(pair[1].size() - 1) == '%') {
                      count = (int) (((double) populations.at(parent).count() / 100) *
                          std::stoi(pair[1].substr(0, pair[1].length() - 1)));
                  } else count = std::stoi(pair[1]);

                  if (count > populations.at(parent).count())
                      throw std::invalid_argument("Not enough samples available to pick " +
                          std::to_string(count) + " in definition \"" + def + "\".");


                  avail_set.clear();
                  for (int j = 0; j < nsamps; ++j) {
                      if (populations.at(parent).at(j)) avail_set.push_back(j);
                  }

                  added.clear();
                  for (size_t k = 0; k < count;) {
                      r = rand() % avail_set.size();
                      if (added.count(avail_set[r]) == 0) {
                          ++k;
                          pop.set(avail_set[r]);
                          added.insert(avail_set[r]);
                      }
                  }

                  populations[parent + GDEF_SCOPE + pair[0].substr(parent_end + 1)] = pop;
                  populations[parent + GDEF_SCOPE + GDEF_NEGATE + pair[0].substr(parent_end + 1)] =
                      ~pop & populations.at(parent);
              }
          }

          for (auto &p : populations) {
              out << p.first << GDEF_ASSIGN << p.second.to_string() << std::endl;
          }

          return true;
      }

      /**
     * @brief
     * Export the graph in DOT format
     * @param filename to export to
     * @param name of the graph
     * @throws std::invalid_argument if output file cannot be opened
     */
      void to_DOT(std::string filename, std::string name) {
          std::ofstream out(filename);
          if (!out.good()) throw std::invalid_argument("Error opening file: \"" + filename + "\"");
          out << to_DOT(name);
      }

      std::string to_DOT(std::string name = "groups") const {
          std::ostringstream dot;
          dot << "digraph " << name << " {\n";
          std::string node_label;
          std::unordered_map<std::string, int> id_map;
          int ids = 0;
          for (const auto &l : _subgraph_filters) {
              node_label = l.first.substr(l.first.find_last_of(GDEF_SCOPE) + 1);
              dot << ++ids << "[label=\"" << node_label << ":" << l.second.count() << "\"];\n";
              id_map[node_label] = ids;
          }

          for (const auto &l : _subgraph_filters) {
              size_t last_scope = l.first.find_last_of(GDEF_SCOPE);
              if (last_scope == std::string::npos) continue;
              std::string root = l.first.substr(0, last_scope);
              dot << id_map.at(root.substr(root.find_last_of(GDEF_SCOPE) + 1))
                  << " -> " << id_map.at(l.first.substr(last_scope + 1)) << ";\n";
          }
          dot << "labelloc=\"t\";\nlabel=\"Subgraph Name : Population Size\";\n}\n";
          return dot.str();
      }

    private:
      std::shared_ptr<const Graph> _base_graph = nullptr;
      std::unordered_map<std::string, Graph::Population> _subgraph_filters;
      std::unordered_map<std::string, std::shared_ptr<const Graph>> _subgraphs;

  };

  /**
 * @brief
 * Provides an interface for working with GDEF files.
 */
  class GDEF {
    public:
      /**
       * @brief
       * Create a new gdef using the given parameters.
       * @param fasta_file file name of reference seq
       * @param var_file file name of VCF or BCF file
       * @param region region of graph, CHR:XX,XXX-YY,YYY
       * @param node_len maximum node length
       */
      GDEF(std::string fasta_file,
           std::string var_file,
           std::string region,
           int node_len) :
          _fasta_file(fasta_file),
          _var_file(var_file),
          _region(region),
          _node_len(node_len) {
          Vargas::VCF vf(var_file);
          _num_samples = vf.num_samples();
      }

      /**
       * @brief
       * Load an existing GDEF file
       * @param file_name GDEF to load
       */
      GDEF(std::string file_name) { load(file_name); }

      /**
       * @brief
       * Load a given GDEF file.
       * @param file_name GDEF file to load
       * @throws std::invalid_argument error opening file, wrong file type, or malformed field
       */
      void load(std::string file_name) {
          std::ifstream in(file_name);
          if (!in.good()) throw std::invalid_argument("Error opening file \"" + file_name + "\"");

          std::string line;
          std::getline(in, line);
          if (line != "@gdef") throw std::invalid_argument("Expected a GDEF file (" + file_name + ")");

          std::getline(in, line);
          std::vector<std::string> tv_pairs = split(line, GDEF_META_DELIM);
          for (auto &tv : tv_pairs) {
              std::vector<std::string> tv_pair = split(tv, GDEF_TAG_VAL_DELIM);
              if (tv_pair.size() != 2) throw std::invalid_argument("Malformed tag-value pair \"" + tv + "\"");
              auto &tag = tv_pair[0];
              auto &val = tv_pair[1];

              if (tag == REF_FILE_TAG) {
                  _fasta_file = val;
              }
              else if (tag == VAR_FILE_TAG) {
                  _var_file = val;
              }
              else if (tag == REGION_TAG) {
                  _region = val;
              }
              else if (tag == NODE_LEN_TAG) {
                  _node_len = std::stoi(val);
              }
          }

          _pops.clear();
          while (std::getline(in, line)) {
              std::vector<std::string> p_pair = split(line, GDEF_POP_DELIM);
              if (p_pair.size() != 2) throw std::invalid_argument("Invalid Graph::GID:Population formation");
              std::vector<std::string> gid = split(p_pair[0], ',');
              if (gid.size() != 4) throw std::invalid_argument("Invalid Graph::GID format");
              Graph::Population pop(p_pair[1].length());
              for (size_t i = 0; i < p_pair[1].length(); ++i) {
                  if (p_pair[1][i] == '1') pop.set(i);
              }
              Graph::GID g(std::stoi(gid[1]), std::stoi(gid[2]), gid[3] == "1");
              g.outgroup = gid[0] == "o";
              add_population(g, pop);
          }
      }

      /**
       * @brief
       * After params have been set, write the gdef to a file.
       * @param file_name output file name.
       */
      void write(std::string file_name) {
          std::ofstream out(file_name);
          if (!out.good()) write(std::cout);
          write(out);
      }

      /**
       * @brief
       * Output to a stream.
       * @param os Output stream.
       */
      void write(std::ostream &os) {
          os << "@gdef\n"
             << REF_FILE_TAG << GDEF_TAG_VAL_DELIM << _fasta_file << GDEF_META_DELIM
             << VAR_FILE_TAG << GDEF_TAG_VAL_DELIM << _var_file << GDEF_META_DELIM
             << REGION_TAG << GDEF_TAG_VAL_DELIM << _region << GDEF_META_DELIM
             << NODE_LEN_TAG << GDEF_TAG_VAL_DELIM << _node_len << std::endl;

          for (auto &tv : _pops) {
              os << tv.first << GDEF_POP_DELIM << tv.second.to_string() << std::endl;
          }
      }

      /**
       * @brief
       * Add a Population to the gdef. All added graphs should
       * be ingroup graphs since outgroups are derived.
       * @param key Graph::GID
       * @param pop Population included in the graph
       * @throws std::invalid_argument outgroup graphs cannot be explicity added
       */
      bool add_population(const Graph::GID &key, const Graph::Population &pop) {
          if (key.outgroup) throw std::invalid_argument("Only ingroup graphs can be explicitly added.");
          if (_pops.find(key) == _pops.end()) _pops[key] = pop;
          else return false;
          return true;
      }

      /**
       * @brief
       * Creates outgroup versions of all graphs that exist.
       */
      void include_outgroups() {
          auto pop_cpy = _pops;
          for (auto &p : pop_cpy) {
              Graph::GID g = p.first;
              g.outgroup = true;
              _pops[g] = ~p.second;
          }
      }

      /**
       * @brief
       * Set the reference file.
       * @param fasta Relative path to fasta file.
       */
      void set_fasta(std::string fasta) { _fasta_file = fasta; }

      /**
       * @brief
       * Set the variant file.
       * @param varfile Relative path to variant file.
       */
      void set_variant(std::string varfile) {
          _var_file = varfile;
          Vargas::VCF vf(_var_file);
          _num_samples = vf.num_samples();
      }

      /**
       * @brief
       * Set the region of the graph to build.
       * @param region format: CHR:XX,XXX-YY,YYY
       */
      void set_region(std::string region) { _region = region; }

      /**
       * @param node_len maximum graph node length
       */
      void set_node_length(int node_len) { _node_len = node_len; }

      /**
       * @brief
       * Maximum node length of graph.
       * @return node length
       */
      int node_len() const { return _node_len; }

      /**
       * @brief
       * Get the number of samples present in the given VCF.
       * @return number of samples, 0 if no var file.
       */
      size_t num_samples() const { return _num_samples; }

      /**
       * @return the specified fasta file.
       */
      std::string fasta() const { return _fasta_file; }

      /**
       * @return the specified variant file.
       */
      std::string var() const { return _var_file; }

      /**
       * @return the specified region.
       */
      std::string region() const { return _region; }

      /**
       * @brief
       * Return a map of all subgraphs defined in the file/added.
       * Outgroup graphs are also included if include_outgroups() was called.
       */
      const std::map<Graph::GID, Graph::Population> &populations() const { return _pops; }


    protected:
      // Used for printing and parsing of files
      const std::string REF_FILE_TAG = "ref";
      const std::string VAR_FILE_TAG = "var";
      const std::string REGION_TAG = "reg";
      const std::string NODE_LEN_TAG = "nlen";
      const char GDEF_META_DELIM = ';';
      const char GDEF_TAG_VAL_DELIM = '=';
      const char GDEF_POP_DELIM = ':';

    private:
      std::string _fasta_file, _var_file;
      std::string _region;
      size_t _node_len = 1000000;
      std::map<Graph::GID, Graph::Population> _pops;
      size_t _num_samples = 0;
  };

}

TEST_CASE ("Graph Manager") {
    using std::endl;
    std::string tmpfa = "tmp_tc.fa";
    {
        std::ofstream fao(tmpfa);
        fao
            << ">x" << endl
            << "CAAATAAGGCTTGGAAATTTTCTGGAGTTCTATTATATTCCAACTCTCTGGTTCCTGGTGCTATGTGTAACTAGTAATGG" << endl
            << "TAATGGATATGTTGGGCTTTTTTCTTTGATTTATTTGAAGTGACGTTTGACAATCTATCACTAGGGGTAATGTGGGGAAA" << endl
            << "TGGAAAGAATACAAGATTTGGAGCCAGACAAATCTGGGTTCAAATCCTCACTTTGCCACATATTAGCCATGTGACTTTGA" << endl
            << "ACAAGTTAGTTAATCTCTCTGAACTTCAGTTTAATTATCTCTAATATGGAGATGATACTACTGACAGCAGAGGTTTGCTG" << endl
            << "TGAAGATTAAATTAGGTGATGCTTGTAAAGCTCAGGGAATAGTGCCTGGCATAGAGGAAAGCCTCTGACAACTGGTAGTT" << endl
            << "ACTGTTATTTACTATGAATCCTCACCTTCCTTGACTTCTTGAAACATTTGGCTATTGACCTCTTTCCTCCTTGAGGCTCT" << endl
            << "TCTGGCTTTTCATTGTCAACACAGTCAACGCTCAATACAAGGGACATTAGGATTGGCAGTAGCTCAGAGATCTCTCTGCT" << endl
            << ">y" << endl
            << "GGAGCCAGACAAATCTGGGTTCAAATCCTGGAGCCAGACAAATCTGGGTTCAAATCCTGGAGCCAGACAAATCTGGGTTC" << endl;
    }
    std::string tmpvcf = "tmp_tc.vcf";

    // Write temp VCF file
    {
        std::ofstream vcfo(tmpvcf);
        vcfo
            << "##fileformat=VCFv4.1" << endl
            << "##phasing=true" << endl
            << "##contig=<ID=x>" << endl
            << "##contig=<ID=y>" << endl
            << "##FORMAT=<ID=GT,Number=1,Type=String,Description=\"Genotype\">" << endl
            << "##INFO=<ID=AF,Number=1,Type=Float,Description=\"Allele Freq\">" << endl
            << "##INFO=<ID=AC,Number=A,Type=Integer,Description=\"Alternate Allele count\">" << endl
            << "##INFO=<ID=NS,Number=1,Type=Integer,Description=\"Num samples at site\">" << endl
            << "##INFO=<ID=NA,Number=1,Type=Integer,Description=\"Num alt alleles\">" << endl
            << "##INFO=<ID=LEN,Number=A,Type=Integer,Description=\"Length of each alt\">" << endl
            << "##INFO=<ID=TYPE,Number=A,Type=String,Description=\"type of variant\">" << endl
            << "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\ts1\ts2" << endl
            << "x\t9\t.\tG\tA,C,T\t99\t.\tAF=0.01,0.6,0.1;AC=1;LEN=1;NA=1;NS=1;TYPE=snp\tGT\t0|1\t2|3" << endl
            << "x\t10\t.\tC\t<CN7>,<CN0>\t99\t.\tAF=0.01,0.01;AC=2;LEN=1;NA=1;NS=1;TYPE=snp\tGT\t1|1\t2|1" << endl
            << "x\t14\t.\tG\t<DUP>,<BLAH>\t99\t.\tAF=0.01,0.1;AC=1;LEN=1;NA=1;NS=1;TYPE=snp\tGT\t1|0\t1|1" << endl
            << "y\t34\t.\tTATA\t<CN2>,<CN0>\t99\t.\tAF=0.01,0.1;AC=2;LEN=1;NA=1;NS=1;TYPE=snp\tGT\t1|1\t2|1" << endl
            << "y\t39\t.\tT\t<CN0>\t99\t.\tAF=0.01;AC=1;LEN=1;NA=1;NS=1;TYPE=snp\tGT\t1|0\t0|1" << endl;
    }

    std::srand(12345);

    std::stringstream ss;

    Vargas::GraphManager gm;
    gm.write(tmpfa, tmpvcf, "x:0-10", "ingroup = 2;~ingroup:1_1=1;ingroup:1_2=1", 100000, ss);
    gm.open(ss);

        CHECK_THROWS(gm.filter("sdf"));

        CHECK(gm.filter("ingroup").count() == 2);
        CHECK((gm.filter("ingroup") && gm.filter("~ingroup")) == 0);
        CHECK(gm.filter("ingroup:1_2").count() == 1);
        CHECK((gm.filter("ingroup:1_2") && gm.filter("ingroup:~1_2")) == 0);
        CHECK((gm.filter("ingroup") && gm.filter("~ingroup:1_1")) == 0);
        CHECK(gm.filter("~ingroup:1_1").count() == 1);

        CHECK((gm.filter("ingroup") | gm.filter("~ingroup")).count() == 4);
        CHECK((gm.filter("ingroup:1_2") | gm.filter("ingroup:~1_2")) == gm.filter("ingroup"));

    {
        auto in_graph = gm.subgraph("ingroup");
            CHECK(in_graph.use_count() == 2);
        gm.destroy("ingroup");
            CHECK(in_graph.use_count() == 1);
    }

    {
        auto in_graph = gm.subgraph("ingroup");
            CHECK(in_graph.use_count() == 2);
        gm.clear();
            CHECK(in_graph.use_count() == 1);
    }

    remove(tmpfa.c_str());
    remove(tmpvcf.c_str());
    remove((tmpfa + ".fai").c_str());

}
#endif //VARGAS_GDEF_H
