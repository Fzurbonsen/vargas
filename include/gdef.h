/**
 * @author Ravi Gaddipati
 * @date July 31, 2016
 * rgaddip1@jhu.edu
 *
 * @brief
 * Defines a set of subgraphs from a given reference
 * and vcf file.
 *
 * @file
 */

#ifndef VARGAS_GDEF_H
#define VARGAS_GDEF_H

#include <string>
#include <map>
#include <fstream>
#include "graph.h"

namespace Vargas {

  /**
   * @brief
   * Create and manage a graph and specified subgraphs.
   * @details
   * Given a reference sequence and a variant call file, a GDEF file uniquely defines a set of
   * subgraphs deriving from the base graph. Subgraphs are generated by filtering the base graph
   * based on the number of samples in the graph. \n
   * Subgraphs are generated from parent graphs, with the top level base graph implied as 100%. ':' indicates
   * a child graph, '~' indicates the complement population. Multiple definitions are delimited with ';',
   * and all labels must be defined before being referenced. For example:
   * @code{.unparsed}
   * "a=10" # Choose 10 samples from the base graph
   * "b=5%" # Choose 5% of the samples in the base graph
   * "a:c=5" # Choose 5 of the 10 samples in 'a'
   * "~a:d=5" # Choose 5 samples from the complement population of 'a'
   * "a:~e=5" # Invalid, complement graphs are implicit and cannot be directly defined.
   * @endcode
   * \n
   * GDEF file format:
   * @code{.unparsed}
   * @gdef
   * ref=REFERENCE,var=VCF,reg=REGION,nlen=NODE_LEN
   * label=POP_FILTER
   * ...
   * @endcode
   * \n
   * Usage:
   * @code{.cpp}
   * #include <gdef.h>
   *
   * int main() {
   *    Vargas::GraphManager gm();
   *    gm.write("ref.fasta", "variants.vcf", "x:0-100", "a=50;a:b=10;~a:c=10%", 1000, "out.gdf");
   *
   *    gm.load("out.gdf");
   *    gm.base(); // shared_ptr to whole graph
   *    gm.subgraph("a"); // 'a' subgraph
   *    gm.subgraph("~a"); // complement of 'a' subgraph
   *    gm.subgraph("c"); // Invalid
   *    gm.subgraph("~a:c") // valid
   *
   * }
   * @endcode
   *
   */
  class GraphManager {
    public:

      GraphManager() {}

      /**
       * @brief
       * Open a GDEF file.
       * @param gdef_file file name
       * @throws std::invalid_argument Failed to open the input file.
       */
      GraphManager(std::string gdef_file);

      ~GraphManager() { close(); }

      /**
       * @brief
       * Remove any graphs.
       */
      void close();

      /**
       * @brief
       * Open a GDEF file.
       * @param file_name
       * @param build_base If true, build the base graph.
       * @return true on success
       */
      bool open(std::string file_name, bool build_base = true);

      /**
       * @brief
       * Read a GDEF file from an input stream
       * @param in input stream
       * @param build_base If true, build the base graph
       * @return true on success
       * @throws std::invalid_argument Invalid token or a duplicate definition
       * @throws std::range_error Filter length does not match the number of samples in the VCF file
       */
      bool open(std::istream &in, bool build_base = true);

      /**
       * @brief
       * Create a subgraph if it does not exist.
       * @param label subgraph name
       * @return shared_ptr to graph
       * @throws std::invalid_argument Label does not exist, or no base graph built
       */
      std::shared_ptr<const Graph> make_subgraph(std::string label);

      /**
       * @brief
       * Get a previously made graph.
       * @param label subgraph name
       * @return shared_ptr to graph
       * @throws std::out_of_range Graph does not exist
     */
      std::shared_ptr<const Graph> subgraph(std::string label) const;

      /**
       * @brief
       * Full graph
       * @return shared_ptr to base graph
       * @throw std::invalid_argument Base graph is not built.
       */
      std::shared_ptr<const Graph> base() const;

      /**
       * @brief
       * Get the population filter for a label
       * @param label subgraph label
       * @return Graph::Population to derive subgraph from base graph
       * @throws std::invalid_argument Label does not exist
       */
      Graph::Population filter(std::string label) const;

      /**
       * @brief
       * Remove local reference to a graph. Removing after creation of the graph
       * will free memory once all users destroy their shared_ptr's.
       * @param label graph name
       */
      void destroy(std::string label) {
          _subgraphs.erase(GDEF_BASE + GDEF_SCOPE + label);
      }

      /**
       * @brief
       * Remove all local references to subgraphs. The base graph is preserved.
       */
      void clear() {
          _subgraphs.clear();
      }

      /**
       * @brief
       * Parse a defintion string a write a GDEF file. Also loads the generated file.
       * @param ref_file Reference file name
       * @param vcf_file Variant file name
       * @param region Region in the format 'CHR:MIN-MAX'
       * @param defs subgraph definition string
       * @param node_len maximum graph node length.
       * @param out_file Output file name
       * @param build_base If true, build the base graph.
       * @return true on success
       * @throws std::invalid_argument Invalid output file
       */
      bool write(std::string ref_file,
                 std::string vcf_file,
                 std::string region,
                 const std::string &defs,
                 int node_len,
                 std::string out_file,
                 bool build_base = true);

      /**
       * @brief
       * Parse a defintion string a write a GDEF file. Also loads the generated file.
       * @param ref_file Reference file name
       * @param vcf_file Variant file name
       * @param region Region in the format 'CHR:MIN-MAX'
       * @param defs subgraph definition string
       * @param node_len maximum graph node length.
       * @param out output stream
       * @param build_base If true, build the base graph.
       * @param nsamps if unspecified the number of samples will be determined from the VCF file
       * @return true on success
       */
      bool write(std::string ref_file,
                 std::string vcf_file,
                 std::string region,
                 std::string defs_str,
                 int node_len,
                 std::ostream &out,
                 bool build_base,
                 int nsamps = 0);

      /**
     * @brief
     * Export the Population graph in DOT format
     * @param filename to export to
     * @param name of the graph
     * @throws std::invalid_argument if output file cannot be opened
     */
      void to_DOT(std::string filename, std::string name) const {
          std::ofstream out(filename);
          if (!out.good()) throw std::invalid_argument("Error opening file: \"" + filename + "\"");
          out << to_DOT(name);
      }

      /**
       * @brief
       * Derive a graph of population dependencies
       * @param name Graph name
       * @return String of population graph in DOT format
       */
      std::string to_DOT(std::string name = "groups") const;

      /**
       * @brief
       * Get a vector of all labels that have a population.
       * @details
       * Each label is fully scoped.
       * @return vector of labels
       */
      std::vector<std::string> labels() const {
          std::vector<std::string> ret;
          for (const auto &pair : _subgraph_filters) {
              ret.push_back(pair.first);
          }
          return ret;
      }

      /**
       * @brief
       * Return the number of subgraphs defined.
       * @return Number of subgraph filters.
       */
      size_t size() const {
          return _subgraph_filters.size();
      }

    private:
      std::shared_ptr<const Graph> _base_graph = nullptr;
      std::unordered_map<std::string, Graph::Population> _subgraph_filters;
      std::unordered_map<std::string, std::shared_ptr<const Graph>> _subgraphs;

      const std::string GDEF_FILE_MARKER = "@gdef";
      const std::string GDEF_REF = "ref";
      const std::string GDEF_VCF = "vcf";
      const std::string GDEF_REGION = "reg";
      const std::string GDEF_NODELEN = "nlen";
      const std::string GDEF_BASE = "BASE";
      const char GDEF_NEGATE = '~';
      const char GDEF_SCOPE = ':';
      const char GDEF_ASSIGN = '=';
      const char GDEF_DELIM = ';';

  };

  /**
 * @brief
 * Provides an interface for working with GDEF files.
 */
  class GDEF {
    public:
      /**
       * @brief
       * Create a new gdef using the given parameters.
       * @param fasta_file file name of reference seq
       * @param var_file file name of VCF or BCF file
       * @param region region of graph, CHR:XX,XXX-YY,YYY
       * @param node_len maximum node length
       */
      GDEF(std::string fasta_file,
           std::string var_file,
           std::string region,
           int node_len) :
          _fasta_file(fasta_file),
          _var_file(var_file),
          _region(region),
          _node_len(node_len) {
          Vargas::VCF vf(var_file);
          _num_samples = vf.num_samples();
      }

      /**
       * @brief
       * Load an existing GDEF file
       * @param file_name GDEF to load
       */
      GDEF(std::string file_name) { load(file_name); }

      /**
       * @brief
       * Load a given GDEF file.
       * @param file_name GDEF file to load
       * @throws std::invalid_argument error opening file, wrong file type, or malformed field
       */
      void load(std::string file_name) {
          std::ifstream in(file_name);
          if (!in.good()) throw std::invalid_argument("Error opening file \"" + file_name + "\"");

          std::string line;
          std::getline(in, line);
          if (line != "@gdef") throw std::invalid_argument("Expected a GDEF file (" + file_name + ")");

          std::getline(in, line);
          std::vector<std::string> tv_pairs = split(line, GDEF_META_DELIM);
          for (auto &tv : tv_pairs) {
              std::vector<std::string> tv_pair = split(tv, GDEF_TAG_VAL_DELIM);
              if (tv_pair.size() != 2) throw std::invalid_argument("Malformed tag-value pair \"" + tv + "\"");
              auto &tag = tv_pair[0];
              auto &val = tv_pair[1];

              if (tag == REF_FILE_TAG) {
                  _fasta_file = val;
              }
              else if (tag == VAR_FILE_TAG) {
                  _var_file = val;
              }
              else if (tag == REGION_TAG) {
                  _region = val;
              }
              else if (tag == NODE_LEN_TAG) {
                  _node_len = std::stoi(val);
              }
          }

          _pops.clear();
          while (std::getline(in, line)) {
              std::vector<std::string> p_pair = split(line, GDEF_POP_DELIM);
              if (p_pair.size() != 2) throw std::invalid_argument("Invalid Graph::GID:Population formation");
              std::vector<std::string> gid = split(p_pair[0], ',');
              if (gid.size() != 4) throw std::invalid_argument("Invalid Graph::GID format");
              Graph::Population pop(p_pair[1].length());
              for (size_t i = 0; i < p_pair[1].length(); ++i) {
                  if (p_pair[1][i] == '1') pop.set(i);
              }
              Graph::GID g(std::stoi(gid[1]), std::stoi(gid[2]), gid[3] == "1");
              g.outgroup = gid[0] == "o";
              add_population(g, pop);
          }
      }

      /**
       * @brief
       * After params have been set, write the gdef to a file.
       * @param file_name output file name.
       */
      void write(std::string file_name) {
          std::ofstream out(file_name);
          if (!out.good()) write(std::cout);
          write(out);
      }

      /**
       * @brief
       * Output to a stream.
       * @param os Output stream.
       */
      void write(std::ostream &os) {
          os << "@gdef\n"
             << REF_FILE_TAG << GDEF_TAG_VAL_DELIM << _fasta_file << GDEF_META_DELIM
             << VAR_FILE_TAG << GDEF_TAG_VAL_DELIM << _var_file << GDEF_META_DELIM
             << REGION_TAG << GDEF_TAG_VAL_DELIM << _region << GDEF_META_DELIM
             << NODE_LEN_TAG << GDEF_TAG_VAL_DELIM << _node_len << std::endl;

          for (auto &tv : _pops) {
              os << tv.first << GDEF_POP_DELIM << tv.second.to_string() << std::endl;
          }
      }

      /**
       * @brief
       * Add a Population to the gdef. All added graphs should
       * be ingroup graphs since outgroups are derived.
       * @param key Graph::GID
       * @param pop Population included in the graph
       * @throws std::invalid_argument outgroup graphs cannot be explicity added
       */
      bool add_population(const Graph::GID &key, const Graph::Population &pop) {
          if (key.outgroup) throw std::invalid_argument("Only ingroup graphs can be explicitly added.");
          if (_pops.find(key) == _pops.end()) _pops[key] = pop;
          else return false;
          return true;
      }

      /**
       * @brief
       * Creates outgroup versions of all graphs that exist.
       */
      void include_outgroups() {
          auto pop_cpy = _pops;
          for (auto &p : pop_cpy) {
              Graph::GID g = p.first;
              g.outgroup = true;
              _pops[g] = ~p.second;
          }
      }

      /**
       * @brief
       * Set the reference file.
       * @param fasta Relative path to fasta file.
       */
      void set_fasta(std::string fasta) { _fasta_file = fasta; }

      /**
       * @brief
       * Set the variant file.
       * @param varfile Relative path to variant file.
       */
      void set_variant(std::string varfile) {
          _var_file = varfile;
          Vargas::VCF vf(_var_file);
          _num_samples = vf.num_samples();
      }

      /**
       * @brief
       * Set the region of the graph to build.
       * @param region format: CHR:XX,XXX-YY,YYY
       */
      void set_region(std::string region) { _region = region; }

      /**
       * @param node_len maximum graph node length
       */
      void set_node_length(int node_len) { _node_len = node_len; }

      /**
       * @brief
       * Maximum node length of graph.
       * @return node length
       */
      int node_len() const { return _node_len; }

      /**
       * @brief
       * Get the number of samples present in the given VCF.
       * @return number of samples, 0 if no var file.
       */
      size_t num_samples() const { return _num_samples; }

      /**
       * @return the specified fasta file.
       */
      std::string fasta() const { return _fasta_file; }

      /**
       * @return the specified variant file.
       */
      std::string var() const { return _var_file; }

      /**
       * @return the specified region.
       */
      std::string region() const { return _region; }

      /**
       * @brief
       * Return a map of all subgraphs defined in the file/added.
       * Outgroup graphs are also included if include_outgroups() was called.
       */
      const std::map<Graph::GID, Graph::Population> &populations() const { return _pops; }


    protected:
      // Used for printing and parsing of files
      const std::string REF_FILE_TAG = "ref";
      const std::string VAR_FILE_TAG = "var";
      const std::string REGION_TAG = "reg";
      const std::string NODE_LEN_TAG = "nlen";
      const char GDEF_META_DELIM = ';';
      const char GDEF_TAG_VAL_DELIM = '=';
      const char GDEF_POP_DELIM = ':';

    private:
      std::string _fasta_file, _var_file;
      std::string _region;
      size_t _node_len = 1000000;
      std::map<Graph::GID, Graph::Population> _pops;
      size_t _num_samples = 0;
  };

}

TEST_CASE ("Graph Manager") {
    using std::endl;
    std::string tmpfa = "tmp_tc.fa";
    {
        std::ofstream fao(tmpfa);
        fao
            << ">x" << endl
            << "CAAATAAGGCTTGGAAATTTTCTGGAGTTCTATTATATTCCAACTCTCTGGTTCCTGGTGCTATGTGTAACTAGTAATGG" << endl
            << "TAATGGATATGTTGGGCTTTTTTCTTTGATTTATTTGAAGTGACGTTTGACAATCTATCACTAGGGGTAATGTGGGGAAA" << endl
            << "TGGAAAGAATACAAGATTTGGAGCCAGACAAATCTGGGTTCAAATCCTCACTTTGCCACATATTAGCCATGTGACTTTGA" << endl
            << "ACAAGTTAGTTAATCTCTCTGAACTTCAGTTTAATTATCTCTAATATGGAGATGATACTACTGACAGCAGAGGTTTGCTG" << endl
            << "TGAAGATTAAATTAGGTGATGCTTGTAAAGCTCAGGGAATAGTGCCTGGCATAGAGGAAAGCCTCTGACAACTGGTAGTT" << endl
            << "ACTGTTATTTACTATGAATCCTCACCTTCCTTGACTTCTTGAAACATTTGGCTATTGACCTCTTTCCTCCTTGAGGCTCT" << endl
            << "TCTGGCTTTTCATTGTCAACACAGTCAACGCTCAATACAAGGGACATTAGGATTGGCAGTAGCTCAGAGATCTCTCTGCT" << endl
            << ">y" << endl
            << "GGAGCCAGACAAATCTGGGTTCAAATCCTGGAGCCAGACAAATCTGGGTTCAAATCCTGGAGCCAGACAAATCTGGGTTC" << endl;
    }
    std::string tmpvcf = "tmp_tc.vcf";

    // Write temp VCF file
    {
        std::ofstream vcfo(tmpvcf);
        vcfo
            << "##fileformat=VCFv4.1" << endl
            << "##phasing=true" << endl
            << "##contig=<ID=x>" << endl
            << "##contig=<ID=y>" << endl
            << "##FORMAT=<ID=GT,Number=1,Type=String,Description=\"Genotype\">" << endl
            << "##INFO=<ID=AF,Number=1,Type=Float,Description=\"Allele Freq\">" << endl
            << "##INFO=<ID=AC,Number=A,Type=Integer,Description=\"Alternate Allele count\">" << endl
            << "##INFO=<ID=NS,Number=1,Type=Integer,Description=\"Num samples at site\">" << endl
            << "##INFO=<ID=NA,Number=1,Type=Integer,Description=\"Num alt alleles\">" << endl
            << "##INFO=<ID=LEN,Number=A,Type=Integer,Description=\"Length of each alt\">" << endl
            << "##INFO=<ID=TYPE,Number=A,Type=String,Description=\"type of variant\">" << endl
            << "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\ts1\ts2" << endl
            << "x\t9\t.\tG\tA,C,T\t99\t.\tAF=0.01,0.6,0.1;AC=1;LEN=1;NA=1;NS=1;TYPE=snp\tGT\t0|1\t2|3" << endl
            << "x\t10\t.\tC\t<CN7>,<CN0>\t99\t.\tAF=0.01,0.01;AC=2;LEN=1;NA=1;NS=1;TYPE=snp\tGT\t1|1\t2|1" << endl
            << "x\t14\t.\tG\t<DUP>,<BLAH>\t99\t.\tAF=0.01,0.1;AC=1;LEN=1;NA=1;NS=1;TYPE=snp\tGT\t1|0\t1|1" << endl
            << "y\t34\t.\tTATA\t<CN2>,<CN0>\t99\t.\tAF=0.01,0.1;AC=2;LEN=1;NA=1;NS=1;TYPE=snp\tGT\t1|1\t2|1" << endl
            << "y\t39\t.\tT\t<CN0>\t99\t.\tAF=0.01;AC=1;LEN=1;NA=1;NS=1;TYPE=snp\tGT\t1|0\t0|1" << endl;
    }

    std::srand(12345);

    std::stringstream ss;

    Vargas::GraphManager gm;
    gm.write(tmpfa, tmpvcf, "x:0-10", "ingroup = 2;~ingroup:1_1=1;ingroup:1_2=1", 100000, ss, true);
    gm.open(ss);

        CHECK_THROWS(gm.filter("sdf"));

        CHECK(gm.filter("ingroup").count() == 2);
        CHECK((gm.filter("ingroup") && gm.filter("~ingroup")) == 0);
        CHECK(gm.filter("ingroup:1_2").count() == 1);
        CHECK((gm.filter("ingroup:1_2") && gm.filter("ingroup:~1_2")) == 0);
        CHECK((gm.filter("ingroup") && gm.filter("~ingroup:1_1")) == 0);
        CHECK(gm.filter("~ingroup:1_1").count() == 1);

        CHECK((gm.filter("ingroup") | gm.filter("~ingroup")).count() == 4);
        CHECK((gm.filter("ingroup:1_2") | gm.filter("ingroup:~1_2")) == gm.filter("ingroup"));

    {
        auto in_graph = gm.make_subgraph("ingroup");
            CHECK(in_graph.use_count() == 2);
        gm.destroy("ingroup");
            CHECK(in_graph.use_count() == 1);
    }

    {
        auto in_graph = gm.make_subgraph("ingroup");
            CHECK(in_graph.use_count() == 2);
        gm.clear();
            CHECK(in_graph.use_count() == 1);
    }

    remove(tmpfa.c_str());
    remove(tmpvcf.c_str());
    remove((tmpfa + ".fai").c_str());

}
#endif //VARGAS_GDEF_H
